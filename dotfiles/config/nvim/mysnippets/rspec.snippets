# snippet anr "and_raise" w
# and_raise(${1:exception})
# endsnippet

snippet bef "before(:each) do ... end"
before(${1::each}) do
  $0
end
endsnippet

snippet con "context 'when ...' do ... end"
context 'when ${1:context}' do
  $0
end
endsnippet

snippet des "describe - block"
describe '${1:subject}' do
  $0
end
endsnippet

snippet exp "expect"
expect(${1:subject}).${2:to} ${3:eq} $0
endsnippet

snippet expr "expect { raise ... }.to raise_error(AppError, /ah/"
expect { ${1:do_something()} }.${2:to} raise_error(${3:AppError}, /${4:foobar}/)
endsnippet

snippet it "it '' do"
it '${1:does something}'${2: do
  $3
end}
endsnippet

snippet iti "it { is_expected.to eq }"
it { is_expected.to ${1:eq }$0 }
endsnippet

snippet itin "it { is_expected.not_to eq }"
it { is_expected.not_to ${1:eq }$0 }
endsnippet

snippet its "its(:um) { is_expected.to eq 'um' }"
its(:${1:symbol}) { is_expected.to ${2:eq} $0 }
endsnippet

snippet itsn "its(:um) { is_expected.not_to eq 'um' }"
its(:${1:symbol}) { is_expected.not_to ${2:eq} $0 }
endsnippet

snippet let "let"
let(:${1:symbol}) { $0 }
endsnippet

snippet let! "let!"
let!(:${1:symbol}) { $0 }
endsnippet

snippet letb "let block"
let :${1:symbol} do
  $2
end
$0
endsnippet

snippet letb! "let! block"
let :${1:symbol} do
  $2
end
$0
endsnippet

snippet raise "raise_error(...)"
raise_error(${1:AppError}, ${2:/${3:msg}/})
endsnippet

snippet spec "sepcify { expect(...).to ... }"
specify { expect(${1:subject}).to ${2:eq} $0 }
endsnippet

snippet specn "sepcify { expect(...).to ... }"
specify { expect(${1:subject}).not_to ${2:eq} $0 }
endsnippet

snippet specr "sepcify { expect {...}.to raise_error() }"
specify { expect { ${1:raise AppError.new} }.to raise_error(${2:AppError}, ${3:/${4:msg}/}) }
endsnippet

snippet sub "subject"
subject { $1 }
endsnippet

snippet subj "subject"
subject(:${1:subject}) { $2 }
endsnippet

snippet subb "subject block"
subject do
  $0
end
endsnippet

snippet subjb "subject(:name) block"
subject ${1:subject} do
  $0
end
endsnippet
# snippet matc "Matcher (Custom)"
# class ${1:ReverseTo}
#   def initialize($3)
#     @$3 = $3
#   end
#
#   def matches?(actual)
#     @actual = actual
#     # Satisfy expectation here. Return false or raise an error if it's not met.
#     ${0:@actual.reverse.should == @$3}
#     true
#   end
#
#   def failure_message_for_should
#     "expected #{@actual.inspect} to $2 #{@$3.inspect}, but it didn't"
#   end
#
#   def failure_message_for_should_not
#     "expected #{@actual.inspect} not to $2 #{@$3.inspect}, but it did"
#   end
# end
#
# def ${2:reverse_to}(${3:expected})
#   $1.new($3)
# end
# endsnippet
#
# snippet mat "Matcher (DSL)"
# RSpec::Matchers.define :${1:name} do |${2:expected}|
#   match do |${3:actual}|
#     $3.$1?($2)
#   end
# end
#
# endsnippet
#
# snippet moc "mock"
# ${1:var} = mock("${2:mock_name}"${3:, :null_object => true})
# $0
# endsnippet
#
# snippet mm "mock_model"
# mock_model(${1:model})$0
# endsnippet
#
# snippet mocw "mock_with"
# RSpec::Runner.configure do |config|
#         config.mock_with :${0:mocha|flexmock|rr}
# end
# endsnippet
#
# snippet on "once" w
# once
# endsnippet
#
# snippet reqs "Require spec_helper"
# require 'spec_helper'
#
#
# endsnippet
#
# snippet stu "stub"
# ${1:double}.stub(:${2:message})$3
# endsnippet
#
# snippet aft "teardown"
# after(${1::each}) do
#   $0
# end
# endsnippet
#
# snippet tw "twice" w
# twice
# endsnippet


# snippet exp "expect to"
# expect do
#   $1
# end.to ${2:change {${3:subject}}.${4:from($5).to($6)}}
# endsnippet
#
# snippet rspec "RSpec spec"
# require 'spec_helper'
#
# describe ${1:Subject} do
#
# end
# endsnippet
#
# snippet rmodel "RSpec model spec"
# require 'spec_helper'
#
# describe ${1:Model} do
#
#   describe "associations" do
#
#   end
#
#   describe "validations" do
#
#   end
#
#   describe "class methods" do
#
#   end
#
#   describe "instance methods" do
#
#   end
# end
# endsnippet
